// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventEnvelope {
    /// === Identification ===
    ///
    /// UUIDv4
    #[prost(string, tag = "1")]
    pub event_id: ::prost::alloc::string::String,
    /// Idempotency key (empty = not set)
    #[prost(string, tag = "2")]
    pub command_id: ::prost::alloc::string::String,
    /// === Tenant/Store Context ===
    #[prost(string, tag = "3")]
    pub tenant_id: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub store_id: ::prost::alloc::string::String,
    /// === Entity Reference ===
    #[prost(string, tag = "5")]
    pub entity_type: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub entity_id: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub event_type: ::prost::alloc::string::String,
    /// === Source Agent ===
    #[prost(string, tag = "8")]
    pub source_agent: ::prost::alloc::string::String,
    /// === VES v1.0 Protocol Fields ===
    ///
    /// Protocol version (1)
    #[prost(uint32, tag = "9")]
    pub ves_version: u32,
    /// Plaintext or encrypted
    #[prost(enumeration = "PayloadKind", tag = "10")]
    pub payload_kind: i32,
    /// === Payload ===
    ///
    /// JSON payload bytes
    #[prost(bytes = "vec", tag = "11")]
    pub payload: ::prost::alloc::vec::Vec<u8>,
    /// Set if payload_kind == ENCRYPTED
    #[prost(message, optional, tag = "12")]
    pub payload_encrypted: ::core::option::Option<EncryptedPayload>,
    /// === Hash Bindings (32-byte SHA-256) ===
    ///
    /// Domain-separated hash
    #[prost(bytes = "vec", tag = "13")]
    pub payload_plain_hash: ::prost::alloc::vec::Vec<u8>,
    /// 32 zeros if plaintext
    #[prost(bytes = "vec", tag = "14")]
    pub payload_cipher_hash: ::prost::alloc::vec::Vec<u8>,
    /// === Signature ===
    ///
    /// Signing key ID
    #[prost(uint32, tag = "15")]
    pub agent_key_id: u32,
    /// Ed25519 signature (64 bytes)
    #[prost(bytes = "vec", tag = "16")]
    pub agent_signature: ::prost::alloc::vec::Vec<u8>,
    /// === Metadata ===
    ///
    /// OCC version (0 = not set)
    #[prost(uint64, tag = "17")]
    pub base_version: u64,
    #[prost(message, optional, tag = "18")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// VES-ENC-1 encrypted payload structure
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EncryptedPayload {
    /// = 1
    #[prost(uint32, tag = "1")]
    pub enc_version: u32,
    /// "AES-256-GCM"
    #[prost(string, tag = "2")]
    pub aead: ::prost::alloc::string::String,
    /// 12 bytes
    #[prost(bytes = "vec", tag = "3")]
    pub nonce: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "4")]
    pub ciphertext: ::prost::alloc::vec::Vec<u8>,
    /// 16 bytes
    #[prost(bytes = "vec", tag = "5")]
    pub tag: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "6")]
    pub hpke: ::core::option::Option<HpkeParams>,
    #[prost(message, repeated, tag = "7")]
    pub recipients: ::prost::alloc::vec::Vec<RecipientKey>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HpkeParams {
    /// "base"
    #[prost(string, tag = "1")]
    pub mode: ::prost::alloc::string::String,
    /// "X25519-HKDF-SHA256"
    #[prost(string, tag = "2")]
    pub kem: ::prost::alloc::string::String,
    /// "HKDF-SHA256"
    #[prost(string, tag = "3")]
    pub kdf: ::prost::alloc::string::String,
    /// "AES-256-GCM"
    #[prost(string, tag = "4")]
    pub aead: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecipientKey {
    #[prost(uint32, tag = "1")]
    pub recipient_kid: u32,
    /// 32 bytes
    #[prost(bytes = "vec", tag = "2")]
    pub ephemeral_public_key: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub wrapped_dek: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SequencedEvent {
    #[prost(message, optional, tag = "1")]
    pub envelope: ::core::option::Option<EventEnvelope>,
    #[prost(uint64, tag = "2")]
    pub sequence_number: u64,
    #[prost(message, optional, tag = "3")]
    pub sequenced_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Empty = not set
    #[prost(bytes = "vec", tag = "4")]
    pub receipt_hash: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PushRequest {
    #[prost(string, tag = "1")]
    pub agent_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub tenant_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub store_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "4")]
    pub events: ::prost::alloc::vec::Vec<EventEnvelope>,
    /// For tracking/idempotency
    #[prost(string, tag = "5")]
    pub request_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PushResponse {
    #[prost(string, tag = "1")]
    pub batch_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(uint32, tag = "3")]
    pub events_accepted: u32,
    #[prost(uint32, tag = "4")]
    pub events_rejected: u32,
    #[prost(uint64, tag = "5")]
    pub sequence_start: u64,
    #[prost(uint64, tag = "6")]
    pub sequence_end: u64,
    #[prost(uint64, tag = "7")]
    pub head_sequence: u64,
    #[prost(message, repeated, tag = "8")]
    pub rejections: ::prost::alloc::vec::Vec<RejectedEvent>,
    /// Null message = not set
    #[prost(message, optional, tag = "9")]
    pub commitment: ::core::option::Option<BatchCommitment>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RejectedEvent {
    #[prost(string, tag = "1")]
    pub event_id: ::prost::alloc::string::String,
    #[prost(enumeration = "RejectionReason", tag = "2")]
    pub reason: i32,
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PullEventsRequest {
    #[prost(string, tag = "1")]
    pub tenant_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub store_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub from_sequence: u64,
    /// Default 100, max 1000
    #[prost(uint32, tag = "4")]
    pub limit: u32,
    /// Filters (empty = no filter)
    #[prost(string, tag = "5")]
    pub entity_type_filter: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub entity_id_filter: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "7")]
    pub event_type_filter: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "8")]
    pub agent_filter: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PullEventsResponse {
    #[prost(message, repeated, tag = "1")]
    pub events: ::prost::alloc::vec::Vec<SequencedEvent>,
    #[prost(uint64, tag = "2")]
    pub next_sequence: u64,
    #[prost(bool, tag = "3")]
    pub has_more: bool,
    #[prost(uint64, tag = "4")]
    pub head_sequence: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSyncStateRequest {
    #[prost(string, tag = "1")]
    pub tenant_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub store_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyncState {
    #[prost(string, tag = "1")]
    pub tenant_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub store_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub head_sequence: u64,
    /// Empty = not available
    #[prost(bytes = "vec", tag = "4")]
    pub state_root: ::prost::alloc::vec::Vec<u8>,
    /// Null message = not available
    #[prost(message, optional, tag = "5")]
    pub latest_commitment: ::core::option::Option<BatchCommitment>,
    #[prost(message, optional, tag = "6")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCommitment {
    #[prost(string, tag = "1")]
    pub batch_id: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub merkle_root: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag = "3")]
    pub start_sequence: u64,
    #[prost(uint64, tag = "4")]
    pub end_sequence: u64,
    #[prost(uint32, tag = "5")]
    pub event_count: u32,
    #[prost(message, optional, tag = "6")]
    pub committed_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Empty = first batch (no previous)
    #[prost(bytes = "vec", tag = "7")]
    pub previous_root: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCommitmentRequest {
    #[prost(oneof = "get_commitment_request::Selector", tags = "1, 2")]
    pub selector: ::core::option::Option<get_commitment_request::Selector>,
}
/// Nested message and enum types in `GetCommitmentRequest`.
pub mod get_commitment_request {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Selector {
        #[prost(string, tag = "1")]
        BatchId(::prost::alloc::string::String),
        #[prost(uint64, tag = "2")]
        SequenceNumber(u64),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetInclusionProofRequest {
    #[prost(string, tag = "1")]
    pub tenant_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub store_id: ::prost::alloc::string::String,
    /// Empty = don't verify root
    #[prost(bytes = "vec", tag = "5")]
    pub expected_root: ::prost::alloc::vec::Vec<u8>,
    #[prost(oneof = "get_inclusion_proof_request::Selector", tags = "3, 4")]
    pub selector: ::core::option::Option<get_inclusion_proof_request::Selector>,
}
/// Nested message and enum types in `GetInclusionProofRequest`.
pub mod get_inclusion_proof_request {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Selector {
        #[prost(string, tag = "3")]
        EventId(::prost::alloc::string::String),
        #[prost(uint64, tag = "4")]
        SequenceNumber(u64),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetInclusionProofResponse {
    #[prost(bool, tag = "1")]
    pub included: bool,
    #[prost(message, optional, tag = "2")]
    pub proof: ::core::option::Option<InclusionProof>,
    #[prost(message, optional, tag = "3")]
    pub event: ::core::option::Option<SequencedEvent>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InclusionProof {
    #[prost(bytes = "vec", tag = "1")]
    pub merkle_root: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag = "2")]
    pub leaf_index: u64,
    #[prost(bytes = "vec", repeated, tag = "3")]
    pub proof_hashes: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(uint64, tag = "4")]
    pub leaf_count: u64,
    #[prost(bytes = "vec", tag = "5")]
    pub leaf_hash: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEntityHistoryRequest {
    #[prost(string, tag = "1")]
    pub tenant_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub store_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub entity_type: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub entity_id: ::prost::alloc::string::String,
    /// 0 = from beginning
    #[prost(uint64, tag = "5")]
    pub from_version: u64,
    /// 0 = to current
    #[prost(uint64, tag = "6")]
    pub to_version: u64,
    /// 0 = default (100)
    #[prost(uint32, tag = "7")]
    pub limit: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEntityHistoryResponse {
    #[prost(message, repeated, tag = "1")]
    pub events: ::prost::alloc::vec::Vec<SequencedEvent>,
    #[prost(uint64, tag = "2")]
    pub current_version: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamEventsRequest {
    #[prost(string, tag = "1")]
    pub tenant_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub store_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub from_sequence: u64,
    /// Filters (empty = no filter)
    #[prost(string, repeated, tag = "4")]
    pub entity_type_filter: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "5")]
    pub event_type_filter: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "6")]
    pub agent_filter: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Options
    ///
    /// Send historical events first
    #[prost(bool, tag = "7")]
    pub include_history: bool,
    /// 0 = no heartbeats
    #[prost(uint32, tag = "8")]
    pub heartbeat_interval_ms: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeEntityRequest {
    #[prost(string, tag = "1")]
    pub tenant_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub store_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub entity_type: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub entity_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "5")]
    pub include_history: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyncMessage {
    #[prost(oneof = "sync_message::Message", tags = "1, 2, 3, 4, 5, 6, 7, 8, 9")]
    pub message: ::core::option::Option<sync_message::Message>,
}
/// Nested message and enum types in `SyncMessage`.
pub mod sync_message {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Message {
        /// Client -> Server
        #[prost(message, tag = "1")]
        Push(super::PushRequest),
        #[prost(message, tag = "2")]
        Pull(super::PullEventsRequest),
        #[prost(message, tag = "3")]
        Ack(super::EventAck),
        #[prost(message, tag = "4")]
        Heartbeat(super::Heartbeat),
        /// Server -> Client
        #[prost(message, tag = "5")]
        PushResponse(super::PushResponse),
        #[prost(message, tag = "6")]
        PullResponse(super::PullEventsResponse),
        #[prost(message, tag = "7")]
        Event(super::SequencedEvent),
        #[prost(message, tag = "8")]
        SyncState(super::SyncState),
        #[prost(message, tag = "9")]
        ServerHeartbeat(super::Heartbeat),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventAck {
    #[prost(uint64, repeated, tag = "1")]
    pub sequence_numbers: ::prost::alloc::vec::Vec<u64>,
    #[prost(uint64, tag = "2")]
    pub agent_head_sequence: u64,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Heartbeat {
    #[prost(message, optional, tag = "1")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(uint64, tag = "2")]
    pub last_seen_sequence: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterKeyRequest {
    #[prost(string, tag = "1")]
    pub tenant_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub agent_id: ::prost::alloc::string::String,
    #[prost(uint32, tag = "3")]
    pub key_id: u32,
    #[prost(enumeration = "KeyType", tag = "4")]
    pub key_type: i32,
    /// 32 bytes Ed25519 or X25519
    #[prost(bytes = "vec", tag = "5")]
    pub public_key: ::prost::alloc::vec::Vec<u8>,
    /// Null = immediately valid
    #[prost(message, optional, tag = "6")]
    pub valid_from: ::core::option::Option<::prost_types::Timestamp>,
    /// Null = no expiration
    #[prost(message, optional, tag = "7")]
    pub valid_to: ::core::option::Option<::prost_types::Timestamp>,
    /// Signature proving ownership
    #[prost(bytes = "vec", tag = "8")]
    pub proof_of_possession: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterKeyResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub registered_at: ::core::option::Option<::prost_types::Timestamp>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAgentKeysRequest {
    #[prost(string, tag = "1")]
    pub tenant_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub agent_id: ::prost::alloc::string::String,
    /// UNSPECIFIED = all types
    #[prost(enumeration = "KeyType", tag = "3")]
    pub key_type_filter: i32,
    #[prost(bool, tag = "4")]
    pub include_revoked: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAgentKeysResponse {
    #[prost(message, repeated, tag = "1")]
    pub keys: ::prost::alloc::vec::Vec<AgentKey>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AgentKey {
    #[prost(uint32, tag = "1")]
    pub key_id: u32,
    #[prost(enumeration = "KeyType", tag = "2")]
    pub key_type: i32,
    #[prost(bytes = "vec", tag = "3")]
    pub public_key: ::prost::alloc::vec::Vec<u8>,
    #[prost(enumeration = "KeyStatus", tag = "4")]
    pub status: i32,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Null = always valid
    #[prost(message, optional, tag = "6")]
    pub valid_from: ::core::option::Option<::prost_types::Timestamp>,
    /// Null = no expiration
    #[prost(message, optional, tag = "7")]
    pub valid_to: ::core::option::Option<::prost_types::Timestamp>,
    /// Null = not revoked
    #[prost(message, optional, tag = "8")]
    pub revoked_at: ::core::option::Option<::prost_types::Timestamp>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RevokeKeyRequest {
    #[prost(string, tag = "1")]
    pub tenant_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub agent_id: ::prost::alloc::string::String,
    #[prost(uint32, tag = "3")]
    pub key_id: u32,
    #[prost(string, tag = "4")]
    pub reason: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "5")]
    pub authorization_signature: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RevokeKeyResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(message, optional, tag = "2")]
    pub revoked_at: ::core::option::Option<::prost_types::Timestamp>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HealthResponse {
    #[prost(bool, tag = "1")]
    pub healthy: bool,
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PayloadKind {
    Unspecified = 0,
    Plaintext = 1,
    Encrypted = 2,
}
impl PayloadKind {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PAYLOAD_KIND_UNSPECIFIED",
            Self::Plaintext => "PAYLOAD_KIND_PLAINTEXT",
            Self::Encrypted => "PAYLOAD_KIND_ENCRYPTED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PAYLOAD_KIND_UNSPECIFIED" => Some(Self::Unspecified),
            "PAYLOAD_KIND_PLAINTEXT" => Some(Self::Plaintext),
            "PAYLOAD_KIND_ENCRYPTED" => Some(Self::Encrypted),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RejectionReason {
    Unspecified = 0,
    InvalidSignature = 1,
    UnknownKey = 2,
    RevokedKey = 3,
    DuplicateEvent = 4,
    DuplicateCommand = 5,
    InvalidHash = 6,
    VersionConflict = 7,
    InvalidFormat = 8,
    QuotaExceeded = 9,
}
impl RejectionReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "REJECTION_REASON_UNSPECIFIED",
            Self::InvalidSignature => "REJECTION_REASON_INVALID_SIGNATURE",
            Self::UnknownKey => "REJECTION_REASON_UNKNOWN_KEY",
            Self::RevokedKey => "REJECTION_REASON_REVOKED_KEY",
            Self::DuplicateEvent => "REJECTION_REASON_DUPLICATE_EVENT",
            Self::DuplicateCommand => "REJECTION_REASON_DUPLICATE_COMMAND",
            Self::InvalidHash => "REJECTION_REASON_INVALID_HASH",
            Self::VersionConflict => "REJECTION_REASON_VERSION_CONFLICT",
            Self::InvalidFormat => "REJECTION_REASON_INVALID_FORMAT",
            Self::QuotaExceeded => "REJECTION_REASON_QUOTA_EXCEEDED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "REJECTION_REASON_UNSPECIFIED" => Some(Self::Unspecified),
            "REJECTION_REASON_INVALID_SIGNATURE" => Some(Self::InvalidSignature),
            "REJECTION_REASON_UNKNOWN_KEY" => Some(Self::UnknownKey),
            "REJECTION_REASON_REVOKED_KEY" => Some(Self::RevokedKey),
            "REJECTION_REASON_DUPLICATE_EVENT" => Some(Self::DuplicateEvent),
            "REJECTION_REASON_DUPLICATE_COMMAND" => Some(Self::DuplicateCommand),
            "REJECTION_REASON_INVALID_HASH" => Some(Self::InvalidHash),
            "REJECTION_REASON_VERSION_CONFLICT" => Some(Self::VersionConflict),
            "REJECTION_REASON_INVALID_FORMAT" => Some(Self::InvalidFormat),
            "REJECTION_REASON_QUOTA_EXCEEDED" => Some(Self::QuotaExceeded),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum KeyType {
    Unspecified = 0,
    /// Ed25519
    Signing = 1,
    /// X25519
    Encryption = 2,
}
impl KeyType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "KEY_TYPE_UNSPECIFIED",
            Self::Signing => "KEY_TYPE_SIGNING",
            Self::Encryption => "KEY_TYPE_ENCRYPTION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "KEY_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "KEY_TYPE_SIGNING" => Some(Self::Signing),
            "KEY_TYPE_ENCRYPTION" => Some(Self::Encryption),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum KeyStatus {
    Unspecified = 0,
    Active = 1,
    Expired = 2,
    Revoked = 3,
}
impl KeyStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "KEY_STATUS_UNSPECIFIED",
            Self::Active => "KEY_STATUS_ACTIVE",
            Self::Expired => "KEY_STATUS_EXPIRED",
            Self::Revoked => "KEY_STATUS_REVOKED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "KEY_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "KEY_STATUS_ACTIVE" => Some(Self::Active),
            "KEY_STATUS_EXPIRED" => Some(Self::Expired),
            "KEY_STATUS_REVOKED" => Some(Self::Revoked),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod sequencer_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct SequencerClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SequencerClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SequencerClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SequencerClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SequencerClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Push a batch of events for sequencing
        pub async fn push(
            &mut self,
            request: impl tonic::IntoRequest<super::PushRequest>,
        ) -> std::result::Result<tonic::Response<super::PushResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/stateset.sequencer.v2.Sequencer/Push",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("stateset.sequencer.v2.Sequencer", "Push"));
            self.inner.unary(req, path, codec).await
        }
        /// Pull events (unary, for simple polling)
        pub async fn pull_events(
            &mut self,
            request: impl tonic::IntoRequest<super::PullEventsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PullEventsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/stateset.sequencer.v2.Sequencer/PullEvents",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("stateset.sequencer.v2.Sequencer", "PullEvents"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get current sync state
        pub async fn get_sync_state(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSyncStateRequest>,
        ) -> std::result::Result<tonic::Response<super::SyncState>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/stateset.sequencer.v2.Sequencer/GetSyncState",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("stateset.sequencer.v2.Sequencer", "GetSyncState"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get Merkle inclusion proof
        pub async fn get_inclusion_proof(
            &mut self,
            request: impl tonic::IntoRequest<super::GetInclusionProofRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetInclusionProofResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/stateset.sequencer.v2.Sequencer/GetInclusionProof",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "stateset.sequencer.v2.Sequencer",
                        "GetInclusionProof",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get batch commitment
        pub async fn get_commitment(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCommitmentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchCommitment>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/stateset.sequencer.v2.Sequencer/GetCommitment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("stateset.sequencer.v2.Sequencer", "GetCommitment"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get entity event history
        pub async fn get_entity_history(
            &mut self,
            request: impl tonic::IntoRequest<super::GetEntityHistoryRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetEntityHistoryResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/stateset.sequencer.v2.Sequencer/GetEntityHistory",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "stateset.sequencer.v2.Sequencer",
                        "GetEntityHistory",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Health check
        pub async fn get_health(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<super::HealthResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/stateset.sequencer.v2.Sequencer/GetHealth",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("stateset.sequencer.v2.Sequencer", "GetHealth"));
            self.inner.unary(req, path, codec).await
        }
        /// Server-side streaming: continuous event delivery
        pub async fn stream_events(
            &mut self,
            request: impl tonic::IntoRequest<super::StreamEventsRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::SequencedEvent>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/stateset.sequencer.v2.Sequencer/StreamEvents",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("stateset.sequencer.v2.Sequencer", "StreamEvents"),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Bidirectional streaming: full-duplex sync
        pub async fn sync_stream(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::SyncMessage>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::SyncMessage>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/stateset.sequencer.v2.Sequencer/SyncStream",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("stateset.sequencer.v2.Sequencer", "SyncStream"),
                );
            self.inner.streaming(req, path, codec).await
        }
        /// Subscribe to specific entity updates
        pub async fn subscribe_entity(
            &mut self,
            request: impl tonic::IntoRequest<super::SubscribeEntityRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::SequencedEvent>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/stateset.sequencer.v2.Sequencer/SubscribeEntity",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("stateset.sequencer.v2.Sequencer", "SubscribeEntity"),
                );
            self.inner.server_streaming(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod key_management_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Key management service (separate for modularity)
    #[derive(Debug, Clone)]
    pub struct KeyManagementClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl KeyManagementClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> KeyManagementClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> KeyManagementClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            KeyManagementClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn register_agent_key(
            &mut self,
            request: impl tonic::IntoRequest<super::RegisterKeyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RegisterKeyResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/stateset.sequencer.v2.KeyManagement/RegisterAgentKey",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "stateset.sequencer.v2.KeyManagement",
                        "RegisterAgentKey",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_agent_keys(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAgentKeysRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetAgentKeysResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/stateset.sequencer.v2.KeyManagement/GetAgentKeys",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "stateset.sequencer.v2.KeyManagement",
                        "GetAgentKeys",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn revoke_agent_key(
            &mut self,
            request: impl tonic::IntoRequest<super::RevokeKeyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RevokeKeyResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/stateset.sequencer.v2.KeyManagement/RevokeAgentKey",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "stateset.sequencer.v2.KeyManagement",
                        "RevokeAgentKey",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod sequencer_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with SequencerServer.
    #[async_trait]
    pub trait Sequencer: std::marker::Send + std::marker::Sync + 'static {
        /// Push a batch of events for sequencing
        async fn push(
            &self,
            request: tonic::Request<super::PushRequest>,
        ) -> std::result::Result<tonic::Response<super::PushResponse>, tonic::Status>;
        /// Pull events (unary, for simple polling)
        async fn pull_events(
            &self,
            request: tonic::Request<super::PullEventsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PullEventsResponse>,
            tonic::Status,
        >;
        /// Get current sync state
        async fn get_sync_state(
            &self,
            request: tonic::Request<super::GetSyncStateRequest>,
        ) -> std::result::Result<tonic::Response<super::SyncState>, tonic::Status>;
        /// Get Merkle inclusion proof
        async fn get_inclusion_proof(
            &self,
            request: tonic::Request<super::GetInclusionProofRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetInclusionProofResponse>,
            tonic::Status,
        >;
        /// Get batch commitment
        async fn get_commitment(
            &self,
            request: tonic::Request<super::GetCommitmentRequest>,
        ) -> std::result::Result<tonic::Response<super::BatchCommitment>, tonic::Status>;
        /// Get entity event history
        async fn get_entity_history(
            &self,
            request: tonic::Request<super::GetEntityHistoryRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetEntityHistoryResponse>,
            tonic::Status,
        >;
        /// Health check
        async fn get_health(
            &self,
            request: tonic::Request<()>,
        ) -> std::result::Result<tonic::Response<super::HealthResponse>, tonic::Status>;
        /// Server streaming response type for the StreamEvents method.
        type StreamEventsStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::SequencedEvent, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Server-side streaming: continuous event delivery
        async fn stream_events(
            &self,
            request: tonic::Request<super::StreamEventsRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::StreamEventsStream>,
            tonic::Status,
        >;
        /// Server streaming response type for the SyncStream method.
        type SyncStreamStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::SyncMessage, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Bidirectional streaming: full-duplex sync
        async fn sync_stream(
            &self,
            request: tonic::Request<tonic::Streaming<super::SyncMessage>>,
        ) -> std::result::Result<tonic::Response<Self::SyncStreamStream>, tonic::Status>;
        /// Server streaming response type for the SubscribeEntity method.
        type SubscribeEntityStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::SequencedEvent, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Subscribe to specific entity updates
        async fn subscribe_entity(
            &self,
            request: tonic::Request<super::SubscribeEntityRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::SubscribeEntityStream>,
            tonic::Status,
        >;
    }
    #[derive(Debug)]
    pub struct SequencerServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> SequencerServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for SequencerServer<T>
    where
        T: Sequencer,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/stateset.sequencer.v2.Sequencer/Push" => {
                    #[allow(non_camel_case_types)]
                    struct PushSvc<T: Sequencer>(pub Arc<T>);
                    impl<T: Sequencer> tonic::server::UnaryService<super::PushRequest>
                    for PushSvc<T> {
                        type Response = super::PushResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PushRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Sequencer>::push(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PushSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/stateset.sequencer.v2.Sequencer/PullEvents" => {
                    #[allow(non_camel_case_types)]
                    struct PullEventsSvc<T: Sequencer>(pub Arc<T>);
                    impl<
                        T: Sequencer,
                    > tonic::server::UnaryService<super::PullEventsRequest>
                    for PullEventsSvc<T> {
                        type Response = super::PullEventsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PullEventsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Sequencer>::pull_events(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PullEventsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/stateset.sequencer.v2.Sequencer/GetSyncState" => {
                    #[allow(non_camel_case_types)]
                    struct GetSyncStateSvc<T: Sequencer>(pub Arc<T>);
                    impl<
                        T: Sequencer,
                    > tonic::server::UnaryService<super::GetSyncStateRequest>
                    for GetSyncStateSvc<T> {
                        type Response = super::SyncState;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetSyncStateRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Sequencer>::get_sync_state(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetSyncStateSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/stateset.sequencer.v2.Sequencer/GetInclusionProof" => {
                    #[allow(non_camel_case_types)]
                    struct GetInclusionProofSvc<T: Sequencer>(pub Arc<T>);
                    impl<
                        T: Sequencer,
                    > tonic::server::UnaryService<super::GetInclusionProofRequest>
                    for GetInclusionProofSvc<T> {
                        type Response = super::GetInclusionProofResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetInclusionProofRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Sequencer>::get_inclusion_proof(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetInclusionProofSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/stateset.sequencer.v2.Sequencer/GetCommitment" => {
                    #[allow(non_camel_case_types)]
                    struct GetCommitmentSvc<T: Sequencer>(pub Arc<T>);
                    impl<
                        T: Sequencer,
                    > tonic::server::UnaryService<super::GetCommitmentRequest>
                    for GetCommitmentSvc<T> {
                        type Response = super::BatchCommitment;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetCommitmentRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Sequencer>::get_commitment(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetCommitmentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/stateset.sequencer.v2.Sequencer/GetEntityHistory" => {
                    #[allow(non_camel_case_types)]
                    struct GetEntityHistorySvc<T: Sequencer>(pub Arc<T>);
                    impl<
                        T: Sequencer,
                    > tonic::server::UnaryService<super::GetEntityHistoryRequest>
                    for GetEntityHistorySvc<T> {
                        type Response = super::GetEntityHistoryResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetEntityHistoryRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Sequencer>::get_entity_history(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetEntityHistorySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/stateset.sequencer.v2.Sequencer/GetHealth" => {
                    #[allow(non_camel_case_types)]
                    struct GetHealthSvc<T: Sequencer>(pub Arc<T>);
                    impl<T: Sequencer> tonic::server::UnaryService<()>
                    for GetHealthSvc<T> {
                        type Response = super::HealthResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Sequencer>::get_health(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetHealthSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/stateset.sequencer.v2.Sequencer/StreamEvents" => {
                    #[allow(non_camel_case_types)]
                    struct StreamEventsSvc<T: Sequencer>(pub Arc<T>);
                    impl<
                        T: Sequencer,
                    > tonic::server::ServerStreamingService<super::StreamEventsRequest>
                    for StreamEventsSvc<T> {
                        type Response = super::SequencedEvent;
                        type ResponseStream = T::StreamEventsStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StreamEventsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Sequencer>::stream_events(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = StreamEventsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/stateset.sequencer.v2.Sequencer/SyncStream" => {
                    #[allow(non_camel_case_types)]
                    struct SyncStreamSvc<T: Sequencer>(pub Arc<T>);
                    impl<
                        T: Sequencer,
                    > tonic::server::StreamingService<super::SyncMessage>
                    for SyncStreamSvc<T> {
                        type Response = super::SyncMessage;
                        type ResponseStream = T::SyncStreamStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<tonic::Streaming<super::SyncMessage>>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Sequencer>::sync_stream(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SyncStreamSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/stateset.sequencer.v2.Sequencer/SubscribeEntity" => {
                    #[allow(non_camel_case_types)]
                    struct SubscribeEntitySvc<T: Sequencer>(pub Arc<T>);
                    impl<
                        T: Sequencer,
                    > tonic::server::ServerStreamingService<
                        super::SubscribeEntityRequest,
                    > for SubscribeEntitySvc<T> {
                        type Response = super::SequencedEvent;
                        type ResponseStream = T::SubscribeEntityStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SubscribeEntityRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Sequencer>::subscribe_entity(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SubscribeEntitySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for SequencerServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "stateset.sequencer.v2.Sequencer";
    impl<T> tonic::server::NamedService for SequencerServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Generated server implementations.
pub mod key_management_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with KeyManagementServer.
    #[async_trait]
    pub trait KeyManagement: std::marker::Send + std::marker::Sync + 'static {
        async fn register_agent_key(
            &self,
            request: tonic::Request<super::RegisterKeyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RegisterKeyResponse>,
            tonic::Status,
        >;
        async fn get_agent_keys(
            &self,
            request: tonic::Request<super::GetAgentKeysRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetAgentKeysResponse>,
            tonic::Status,
        >;
        async fn revoke_agent_key(
            &self,
            request: tonic::Request<super::RevokeKeyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RevokeKeyResponse>,
            tonic::Status,
        >;
    }
    /// Key management service (separate for modularity)
    #[derive(Debug)]
    pub struct KeyManagementServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> KeyManagementServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for KeyManagementServer<T>
    where
        T: KeyManagement,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/stateset.sequencer.v2.KeyManagement/RegisterAgentKey" => {
                    #[allow(non_camel_case_types)]
                    struct RegisterAgentKeySvc<T: KeyManagement>(pub Arc<T>);
                    impl<
                        T: KeyManagement,
                    > tonic::server::UnaryService<super::RegisterKeyRequest>
                    for RegisterAgentKeySvc<T> {
                        type Response = super::RegisterKeyResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RegisterKeyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as KeyManagement>::register_agent_key(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RegisterAgentKeySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/stateset.sequencer.v2.KeyManagement/GetAgentKeys" => {
                    #[allow(non_camel_case_types)]
                    struct GetAgentKeysSvc<T: KeyManagement>(pub Arc<T>);
                    impl<
                        T: KeyManagement,
                    > tonic::server::UnaryService<super::GetAgentKeysRequest>
                    for GetAgentKeysSvc<T> {
                        type Response = super::GetAgentKeysResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetAgentKeysRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as KeyManagement>::get_agent_keys(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetAgentKeysSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/stateset.sequencer.v2.KeyManagement/RevokeAgentKey" => {
                    #[allow(non_camel_case_types)]
                    struct RevokeAgentKeySvc<T: KeyManagement>(pub Arc<T>);
                    impl<
                        T: KeyManagement,
                    > tonic::server::UnaryService<super::RevokeKeyRequest>
                    for RevokeAgentKeySvc<T> {
                        type Response = super::RevokeKeyResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RevokeKeyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as KeyManagement>::revoke_agent_key(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RevokeAgentKeySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for KeyManagementServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "stateset.sequencer.v2.KeyManagement";
    impl<T> tonic::server::NamedService for KeyManagementServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
